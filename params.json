{"name":"Backbone-validator","tagline":"Backbone model-view validator","body":"backbone-validator v0.1.1 [![Build Status](https://travis-ci.org/fantactuka/backbone-validator.png?branch=master)](https://travis-ci.org/fantactuka/backbone-validator)\r\n==================\r\n\r\nBackbone model validator allows you to define validation rules for model and utilize it for model-standalone validation or bind its events to the view so you can display errors if needed. Inspired by @thedersen's backbone-validation\r\n\r\n# Installation\r\nUsing [Bower](http://twitter.github.com/bower/) `bower install backbone-validator` or just copy [backbone-validator.js](https://raw.github.com/fantactuka/backbone-validator/master/backbone-validator.js)\r\n\r\n# Examples\r\n* **[JSFiddle](http://jsfiddle.net/fantactuka/6zh5y/)**: Data binding & model validation (with nested attributes) example using [Backbone.Validator](https://github.com/fantactuka/backbone-validator) + [Backbone.Ext](https://github.com/fantactuka/backbone-ext) + [Backbone.Stickit](https://github.com/nytimes/backbone.stickit)\r\n\r\n# Usage\r\n## Model\r\n\r\n```js\r\nvar User = Backbone.Model.extend({\r\n  validation: {\r\n    name: {\r\n      required: true,\r\n      message: 'Name is required'\r\n    },\r\n    \r\n    email: {\r\n      required: true,\r\n      format: 'email',\r\n      message: 'Does not match format'\r\n    },\r\n    \r\n    books: {\r\n      collection: true\r\n    },\r\n    \r\n    phone: [{\r\n      format: 'number',\r\n      message: 'Does not match format'\r\n    }, {\r\n      maxLength: 15,\r\n      message: 'Too long'\r\n    }]\r\n  }\r\n});\r\n\r\nvar user = new User();\r\n```\r\nSetting attributes\r\n```js\r\nuser.set({ email: 'wrong_format_email', phone: 'wrong_format_and_also_very_long' }, { validate: true }); \r\n// Attributes won't be set, since validation failed. Validation errors are stored\r\n\r\nuser.set({ email: 'wrong_format_email', phone: 'wrong_format_and_also_very_long' }, { validate: true, suppress: true }); \r\n// Attributes will be set, but model will trigger its validation events, and store validation errors as for previous case\r\n\r\nuser.validationError; // => { email: ['Does not match format'], phone: ['Does not match format', 'Too long'] };\r\n```\r\nSaving model\r\n```js\r\nuser.save(); \r\n// Validation triggered automatically. If nothing passed, it will validate entire model.\r\n\r\nuser.save({ email: 'user@example.com' }); \r\n// Validation triggered automatically. Validates only email.\r\n```\r\nChecking model validity\r\n```js\r\n// Model#isValidreturns boolean depending on model validity\r\nuser.isValid();                   // Will check all attributes\r\nuser.isValid(['email', 'name']);  // Will check specific attributes\r\nuser.isValid('email');            // Will check specific attribute\r\n\r\n// Model#validate returns null if model is valid (no errors), or errors object if any validation failed\r\nuser.validate();                   // Will check all attributes\r\nuser.validate(['email', 'name']);  // Will check specific attributes\r\nuser.validate('email');            // Will check specific attribute\r\n```\r\n\r\n## View\r\n```js\r\nvar UserView = Backbone.View.extend({\r\n  initialize: function() {\r\n    ...\r\n    this.model = new User();\r\n    this.bindValidation();\r\n  },\r\n  \r\n  onValidField: function(attrName, attrValue, model) {\r\n    // Triggered for each valid attribute\r\n  },\r\n  \r\n  onInvalidField: function(attrName, attrValue, errors, model) {\r\n    // Triggered for each invalid attribute.\r\n  }\r\n});\r\n```\r\n\r\nNote that `onValidField` and `onInvalidField` methods are optional for the view. By default it's taken from Backbone.Validator.ViewCallbacks. So you can override those defaults:\r\n```js\r\nValidator.ViewCallbacks = {\r\n  onValidField: function(name /*, value, model*/) {\r\n    var input = this.$('input[name=\"' + name + '\"]');\r\n    input.next('.error-text').remove();\r\n  },\r\n\r\n  onInvalidField: function(name, value, errors /*, model*/) {\r\n    var input = this.$('input[name=\"' + name + '\"]');\r\n    input.next('.error-text').remove();\r\n    input.after('<div class=\"error-text\">' + errors.join(', ') + '</div>');\r\n  }\r\n};\r\n```\r\n\r\nThese methods could be also passed as option to `bindValidation` method:\r\n```js\r\nbindValidation(this.model, {\r\n  onValidField: function() { ... },\r\n  onInvalidField: function() { ... }\r\n});\r\n```\r\n## Built-in validators\r\n\r\n* `required` - just checks value validity with `!!`\r\n* `collection` - runs validation for models collection/array and returns indexed error object\r\n* `minLength`\r\n* `maxLength`\r\n* `fn` - function that receives attribute value and returns true if it's valid, or false/error message if not\r\n* `format` - pattern matching. **Please note:** format does not require field to exist. E.g. phone number could be optional, but should match format if it is not empty. So in case you need to check field existance as well - use `required` validator.\r\n  * `email`\r\n  * `numeric`\r\n  * `email`\r\n  * `url`\r\n  * It's possible to add custom formats via `Backbone.Validator.formats.phone = /(\\d){3,4}-(\\d){3,4}-(\\d){3,4}/;`\r\n\r\nUsage examples:\r\n```js\r\nvar User = Backbone.Model.extend({\r\n  validation: {\r\n    name: {\r\n      required: true,\r\n      minLength: 2,\r\n      maxLength: 20,\r\n      fn: function(value) {\r\n        return ~valie.indexOf('a') ? 'Name should have at least one \"a\" letter' : true;\r\n      }\r\n    },\r\n    \r\n    phone: {\r\n      format: 'numeric'\r\n    },\r\n    \r\n    documents: {\r\n      collection: true\r\n    }\r\n  }\r\n});\r\n\r\n```\r\n\r\n\r\n## Adding validator\r\n```js\r\nBackbone.Validator.add('myCustomValidator', function(value, expectation) {\r\n  return value * value === expectation;\r\n}, 'Default error message');\r\n```\r\nValidation method could return true/false as well as error message or array of messages which will be treated as validation vailure:\r\n```js\r\nBackbone.Validator.add('myCustomValidator', function(value, expectation) {\r\n  return value === expectation ? true : 'Value does not match expectation. Should be ' + expectation;\r\n});\r\n```\r\n\r\n\r\n## Standalone validator\r\nIn fact you can utilize validator for plain objects, so you can do something like this:\r\n```js\r\nvar validations = {\r\n  name: {\r\n    required: true,\r\n    message: 'Name is required'\r\n  },\r\n  \r\n  email: {\r\n    required: true,\r\n    format: 'email',\r\n    message: 'Does not match format'\r\n  }\r\n};\r\n\r\nBackbone.Validator.validate({ name: '', email: '' }, validations); // -> { name: ['Name is required'], email: ['Does not match format'] }\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}